import math
from fractions import Fraction
from math import gcd
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile
from qiskit_aer import AerSimulator
from qiskit.visualization import plot_histogram
from IPython.display import display

def circuit_amod15(qc, qr, a):
    if a == 2:
        qc.cswap(qr[4], qr[3], qr[2])
        qc.cswap(qr[4], qr[2], qr[1])
        qc.cswap(qr[4], qr[1], qr[0])
    elif a == 7:
        qc.cswap(qr[4], qr[1], qr[0])
        qc.cswap(qr[4], qr[2], qr[1])
        qc.cswap(qr[4], qr[3], qr[2])
        qc.cx(qr[4], qr[3])
        qc.cx(qr[4], qr[2])
        qc.cx(qr[4], qr[1])
        qc.cx(qr[4], qr[0])
    elif a == 8:
        qc.cswap(qr[4], qr[1], qr[0])
        qc.cswap(qr[4], qr[2], qr[1])
        qc.cswap(qr[4], qr[3], qr[2])
    elif a == 11:
        qc.cswap(qr[4], qr[2], qr[0])
        qc.cswap(qr[4], qr[3], qr[1])
        qc.cx(qr[4], qr[3])
        qc.cx(qr[4], qr[2])
        qc.cx(qr[4], qr[1])
        qc.cx(qr[4], qr[0])
    elif a == 13:
        qc.cswap(qr[4], qr[3], qr[2])
        qc.cswap(qr[4], qr[2], qr[1])
        qc.cswap(qr[4], qr[1], qr[0])
        qc.cx(qr[4], qr[3])
        qc.cx(qr[4], qr[2])
        qc.cx(qr[4], qr[1])
        qc.cx(qr[4], qr[0])

def circuit_aperiod15(qc, qr, cr, a):
    if a == 11:
        circuit_11period15(qc, qr, cr)
        return

    qc.x(qr[0])  # initialize work register to |1>

    # Apply a**4 mod 15 (identity)
    qc.h(qr[4])
    qc.h(qr[4])
    qc.measure(qr[4], cr[0])
    qc.reset(qr[4])

    # Apply a**2 mod 15
    qc.h(qr[4])
    qc.cx(qr[4], qr[2])
    qc.cx(qr[4], qr[0])
    with qc.if_test((cr[0], 1)):
        qc.p(math.pi / 2, qr[4])
    qc.h(qr[4])
    qc.measure(qr[4], cr[1])
    qc.reset(qr[4])

    # Apply a mod 15
    qc.h(qr[4])
    circuit_amod15(qc, qr, a)
    with qc.if_test((cr[1], 1)):
        qc.p(math.pi / 4, qr[4])
    with qc.if_test((cr[0], 2)):
        qc.p(math.pi / 2, qr[4])
    with qc.if_test((cr, 3)):
        qc.p(3 * math.pi / 4, qr[4])
    qc.h(qr[4])
    qc.measure(qr[4], cr[2])

def circuit_11period15(qc, qr, cr):
    qc.x(qr[0])

    qc.h(qr[4])
    qc.h(qr[4])
    qc.measure(qr[4], cr[0])
    qc.reset(qr[4])

    qc.h(qr[4])
    with qc.if_test((cr[0], 1)):
        qc.p(math.pi / 2, qr[4])
    qc.h(qr[4])
    qc.measure(qr[4], cr[1])
    qc.reset(qr[4])

    qc.h(qr[4])
    qc.cx(qr[4], qr[3])
    qc.cx(qr[4], qr[1])
    with qc.if_test((cr[1], 1)):
        qc.p(math.pi / 4, qr[4])
    with qc.if_test((cr[0], 2)):
        qc.p(math.pi / 2, qr[4])
    with qc.if_test((cr, 3)):
        qc.p(3 * math.pi / 4, qr[4])
    qc.h(qr[4])
    qc.measure(qr[4], cr[2])

def continued_fraction(x, max_denominator=15):
    return Fraction(x).limit_denominator(max_denominator).denominator

def find_order(measured_value, nqubits, a, N):
    phase = measured_value / (2 ** nqubits)
    r = continued_fraction(phase)
    # Check even order and a^{r/2} != -1 mod N
    if r % 2 != 0:
        return None
    if pow(a, r // 2, N) == N - 1:
        return None
    return r

# Parameters
a = 7
N = 15

# Create quantum and classical registers
q = QuantumRegister(5, 'q')
c = ClassicalRegister(3, 'c')  # 3 classical bits for the 3 measurements
shor = QuantumCircuit(q, c)

# Build the Shor order-finding circuit for a
circuit_aperiod15(shor, q, c, a)

# Draw the circuit and display inline (in Jupyter)
display(shor.draw(output='mpl'))

# Simulation setup and execution
simulator = AerSimulator()
compiled_circuit = transpile(shor, simulator)
job = simulator.run(compiled_circuit, shots=2048)
result = job.result()
counts = result.get_counts(compiled_circuit)

# Plot histogram inline (without .show() to avoid warnings)
display(plot_histogram(counts))

# Post-processing: print frequent measurement results and factors
most_common = sorted(counts.items(), key=lambda item: item[1], reverse=True)
print("Most frequent measurement results (bitstrings):")
for bitstring, count in most_common[:5]:
    print(f"{bitstring}: {count} counts")

def bitstring_to_int(bitstring):
    # Reverse bitstring due to Qiskit bit order
    return int(bitstring[::-1], 2)

for bitstring, count in most_common[:5]:
    value = bitstring_to_int(bitstring)
    order = find_order(value, 3, a, N)
    if order is not None:
        print(f"\nEstimated order r from bitstring '{bitstring}': {order}")
        factor1 = gcd(pow(a, order // 2) - 1, N)
        factor2 = gcd(pow(a, order // 2) + 1, N)
        if factor1 not in [1, N] and factor2 not in [1, N]:
            print(f"Non-trivial factors of {N} found: {factor1} and {factor2}")
            break
else:
    print("\nFailed to find factors from the measured results.")
